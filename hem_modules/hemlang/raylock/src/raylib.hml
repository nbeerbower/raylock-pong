// raylock: Raylib bindings for Hemlock
// Uses Hemlock's FFI to call raylib C functions
//
// Usage:
//   import { InitWindow, CloseWindow, DrawText, RED, KEY_ESCAPE } from "hemlang/raylock";
//
// This file exports:
//   - Raylib struct types (Vector2, Rectangle, Color, Texture2D, etc.)
//   - All raylib FFI functions (export extern fn)
//   - Utility functions (collision detection, math helpers, easing, etc.)
//   - Constants (colors, keys, config flags, etc.)
//
// The raylib library is automatically loaded when you import this module.
// FFI symbols are resolved lazily - only when you actually call the function.
//
// ============================================================================
// TYPE MAPPINGS
// ============================================================================
//    - C bool → Hemlock i32 (0 = false, non-zero = true)
//    - C int → Hemlock i32
//    - C float → Hemlock f32
//    - C double → Hemlock f64
//    - C const char* → Hemlock string
//    - C structs → Hemlock define (FFI struct support)
//
// NOTE: On ARM64 Macs, float parameters may not be passed correctly due to
// an FFI bug. Use integer-based helper functions where available.
// ============================================================================

// Load raylib library (cross-platform)
import { RAYLIB_LOADED } from "./raylib_loader.hml";

// ============================================================================
// Core Structs
// ============================================================================

// Vector2, 2 components
export define Vector2 {
    x: f32,
    y: f32,
}

// Vector3, 3 components
export define Vector3 {
    x: f32,
    y: f32,
    z: f32,
}

// Vector4, 4 components
export define Vector4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
}

// Color, 4 components, RGBA (32-bit)
export define ColorStruct {
    r: u8,
    g: u8,
    b: u8,
    a: u8,
}

// Rectangle, 4 components
export define Rectangle {
    x: f32,
    y: f32,
    width: f32,
    height: f32,
}

// Texture2D - GPU texture data
export define Texture2D {
    id: u32,        // OpenGL texture id
    width: i32,     // Texture base width
    height: i32,    // Texture base height
    mipmaps: i32,   // Mipmap levels, 1 by default
    format: i32,    // Data format (PixelFormat type)
}

// RenderTexture2D - Framebuffer for rendering
export define RenderTexture2D {
    id: u32,            // OpenGL framebuffer object id
    texture: Texture2D, // Color buffer attachment texture
    depth: Texture2D,   // Depth buffer attachment texture
}

// Image - CPU image data
export define Image {
    data: ptr,      // Image raw data
    width: i32,     // Image base width
    height: i32,    // Image base height
    mipmaps: i32,   // Mipmap levels, 1 by default
    format: i32,    // Data format (PixelFormat type)
}

// Camera2D - 2D camera
export define Camera2D {
    offset: Vector2,    // Camera offset (displacement from target)
    target: Vector2,    // Camera target (rotation and zoom origin)
    rotation: f32,      // Camera rotation in degrees
    zoom: f32,          // Camera zoom (scaling)
}

// Sound - Audio stream
export define Sound {
    stream_buffer: ptr,     // Pointer to internal data
    stream_processor: ptr,  // Pointer to internal data
    stream_sampleRate: u32, // Frequency (samples per second)
    stream_sampleSize: u32, // Bit depth (bits per sample)
    stream_channels: u32,   // Number of channels (1-mono, 2-stereo)
    frameCount: u32,        // Total number of frames
}

// Music - Music stream with context
export define Music {
    stream_buffer: ptr,
    stream_processor: ptr,
    stream_sampleRate: u32,
    stream_sampleSize: u32,
    stream_channels: u32,
    frameCount: u32,
    looping: i32,
    ctxType: i32,
    ctxData: ptr,
}

// GlyphInfo - Font glyph info
export define GlyphInfo {
    value: i32,      // Character value (Unicode)
    offsetX: i32,    // Character offset X when drawing
    offsetY: i32,    // Character offset Y when drawing
    advanceX: i32,   // Character advance position X
    image: Image,    // Character image data
}

// Font - Font type with texture and character data
export define Font {
    baseSize: i32,       // Base size (default chars height)
    glyphCount: i32,     // Number of glyph characters
    glyphPadding: i32,   // Padding around the glyph characters
    texture: Texture2D,  // Texture atlas containing the glyphs
    recs: ptr,           // Rectangles in texture for the glyphs
    glyphs: ptr,         // Glyphs info data
}

// ============================================================================
// Core - Window/Context
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn InitWindow(width: i32, height: i32, title: string): void;
export extern fn CloseWindow(): void;
export extern fn WindowShouldClose(): i32;  // C: bool
export extern fn IsWindowReady(): i32;       // C: bool
export extern fn IsWindowFullscreen(): i32;  // C: bool
export extern fn IsWindowHidden(): i32;      // C: bool
export extern fn IsWindowMinimized(): i32;   // C: bool
export extern fn IsWindowMaximized(): i32;   // C: bool
export extern fn IsWindowFocused(): i32;     // C: bool
export extern fn IsWindowResized(): i32;     // C: bool
export extern fn IsWindowState(flag: u32): i32;    // C: bool - Check if specific window flag is enabled
export extern fn SetWindowState(flags: u32): void; // Set window configuration state using flags
export extern fn ClearWindowState(flags: u32): void; // Clear window configuration state flags
export extern fn SetWindowTitle(title: string): void;
export extern fn SetWindowPosition(x: i32, y: i32): void;
export extern fn SetWindowSize(width: i32, height: i32): void;
export extern fn SetWindowMinSize(width: i32, height: i32): void;
export extern fn SetWindowMaxSize(width: i32, height: i32): void;
export extern fn GetScreenWidth(): i32;
export extern fn GetScreenHeight(): i32;
export extern fn GetRenderWidth(): i32;
export extern fn GetRenderHeight(): i32;
export extern fn GetMonitorCount(): i32;
export extern fn GetCurrentMonitor(): i32;
export extern fn GetMonitorWidth(monitor: i32): i32;
export extern fn GetMonitorHeight(monitor: i32): i32;
export extern fn GetMonitorRefreshRate(monitor: i32): i32;
export extern fn GetMonitorPhysicalWidth(monitor: i32): i32;
export extern fn GetMonitorPhysicalHeight(monitor: i32): i32;
export extern fn GetMonitorName(monitor: i32): string;  // C: const char*
export extern fn ToggleFullscreen(): void;
export extern fn ToggleBorderlessWindowed(): void;
export extern fn MaximizeWindow(): void;
export extern fn MinimizeWindow(): void;
export extern fn RestoreWindow(): void;
export extern fn SetWindowOpacity(opacity: f32): void;
export extern fn SetWindowFocused(): void;
export extern fn SetWindowIcon(image: ptr): void;  // Takes Image - may not work correctly
export extern fn SetTargetFPS(fps: i32): void;
export extern fn GetFPS(): i32;
export extern fn GetFrameTime(): f32;
export extern fn GetTime(): f64;

// ============================================================================
// Core - Drawing
// ============================================================================

// Note: ClearBackground takes Color struct (4 bytes RGBA) passed as u32
export extern fn ClearBackground(color: u32): void;
export extern fn BeginDrawing(): void;
export extern fn EndDrawing(): void;

// Blend modes
export extern fn BeginBlendMode(mode: i32): void;
export extern fn EndBlendMode(): void;

// Scissor mode (clipping)
export extern fn BeginScissorMode(x: i32, y: i32, width: i32, height: i32): void;
export extern fn EndScissorMode(): void;

// ============================================================================
// rlgl - Low-level OpenGL-like API (for custom drawing)
// ============================================================================
// These functions allow drawing primitives without Vector2 struct issues

export extern fn rlBegin(mode: i32): void;       // Begin vertex definition
export extern fn rlEnd(): void;                   // End vertex definition
export extern fn rlVertex2f(x: f32, y: f32): void;  // Define vertex position (float)
export extern fn rlVertex2i(x: i32, y: i32): void;  // Define vertex position (int)
export extern fn rlColor4ub(r: u8, g: u8, b: u8, a: u8): void;  // Define vertex color

// rlgl drawing modes
export let RL_LINES = 1;
export let RL_TRIANGLES = 4;
export let RL_QUADS = 7;

// ============================================================================
// Core - Input: Keyboard
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn IsKeyPressed(key: i32): i32;       // C: bool
export extern fn IsKeyPressedRepeat(key: i32): i32; // C: bool
export extern fn IsKeyDown(key: i32): i32;          // C: bool
export extern fn IsKeyReleased(key: i32): i32;      // C: bool
export extern fn IsKeyUp(key: i32): i32;            // C: bool
export extern fn GetKeyPressed(): i32;   // Get key pressed (keycode), call multiple times for queued keys
export extern fn GetCharPressed(): i32;  // Get char pressed (unicode), call multiple times for queued chars
export extern fn GetKeyName(key: i32): string;  // C: const char* - Get name of key
export extern fn SetExitKey(key: i32): void;

// ============================================================================
// Core - Input: Mouse
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn IsMouseButtonPressed(button: i32): i32;   // C: bool
export extern fn IsMouseButtonDown(button: i32): i32;      // C: bool
export extern fn IsMouseButtonReleased(button: i32): i32;  // C: bool
export extern fn IsMouseButtonUp(button: i32): i32;        // C: bool
export extern fn GetMouseX(): i32;
export extern fn GetMouseY(): i32;
export extern fn GetMousePosition(): Vector2;
export extern fn GetMouseDelta(): Vector2;
export extern fn GetMouseWheelMove(): f32;
export extern fn GetMouseWheelMoveV(): Vector2;
export extern fn SetMousePosition(x: i32, y: i32): void;
export extern fn SetMouseOffset(offsetX: i32, offsetY: i32): void;
export extern fn SetMouseScale(scaleX: f32, scaleY: f32): void;
export extern fn SetMouseCursor(cursor: i32): void;  // Set mouse cursor (MOUSE_CURSOR_* constants)
export extern fn ShowCursor(): void;
export extern fn HideCursor(): void;
export extern fn IsCursorHidden(): i32;    // C: bool
export extern fn EnableCursor(): void;
export extern fn DisableCursor(): void;
export extern fn IsCursorOnScreen(): i32;  // C: bool

// ============================================================================
// Core - Input: Gamepad
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn IsGamepadAvailable(gamepad: i32): i32;           // C: bool
export extern fn GetGamepadName(gamepad: i32): string;            // C: const char*
export extern fn IsGamepadButtonPressed(gamepad: i32, button: i32): i32;   // C: bool
export extern fn IsGamepadButtonDown(gamepad: i32, button: i32): i32;      // C: bool
export extern fn IsGamepadButtonReleased(gamepad: i32, button: i32): i32;  // C: bool
export extern fn IsGamepadButtonUp(gamepad: i32, button: i32): i32;        // C: bool
export extern fn GetGamepadButtonPressed(): i32;
export extern fn GetGamepadAxisCount(gamepad: i32): i32;
export extern fn GetGamepadAxisMovement(gamepad: i32, axis: i32): f32;
export extern fn SetGamepadMappings(mappings: string): i32;
export extern fn SetGamepadVibration(gamepad: i32, leftMotor: f32, rightMotor: f32, duration: f32): void;

// ============================================================================
// Core - Input: Touch
// ============================================================================

export extern fn GetTouchX(): i32;
export extern fn GetTouchY(): i32;
export extern fn GetTouchPosition(index: i32): Vector2;
export extern fn GetTouchPointId(index: i32): i32;
export extern fn GetTouchPointCount(): i32;

// ============================================================================
// Core - Gestures
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn SetGesturesEnabled(flags: u32): void;
export extern fn IsGestureDetected(gesture: u32): i32;  // C: bool
export extern fn GetGestureDetected(): i32;
export extern fn GetGestureHoldDuration(): f32;
export extern fn GetGestureDragAngle(): f32;
export extern fn GetGesturePinchAngle(): f32;

// ============================================================================
// Core - Logging
// ============================================================================

export extern fn TraceLog(logLevel: i32, text: string): void;
export extern fn SetTraceLogLevel(logLevel: i32): void;

// ============================================================================
// Shapes - Basic Drawing
// ============================================================================
// NOTE: Color is passed as u32 (RGBA packed) which matches raylib's Color struct layout
// NOTE: On ARM64 Macs, float parameters may not work correctly - use integer helpers if needed

export extern fn DrawPixel(posX: i32, posY: i32, color: u32): void;
export extern fn DrawPixelV(position: Vector2, color: u32): void;
export extern fn DrawLine(startPosX: i32, startPosY: i32, endPosX: i32, endPosY: i32, color: u32): void;
export extern fn DrawLineV(startPos: Vector2, endPos: Vector2, color: u32): void;
export extern fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: u32): void;
export extern fn DrawLineStrip(points: ptr, pointCount: i32, color: u32): void;  // points: Vector2*
export extern fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: u32): void;
export extern fn DrawCircle(centerX: i32, centerY: i32, radius: f32, color: u32): void;
export extern fn DrawCircleV(center: Vector2, radius: f32, color: u32): void;
export extern fn DrawCircleGradient(centerX: i32, centerY: i32, radius: f32, color1: u32, color2: u32): void;
export extern fn DrawCircleLines(centerX: i32, centerY: i32, radius: f32, color: u32): void;
export extern fn DrawCircleLinesV(center: Vector2, radius: f32, color: u32): void;
export extern fn DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: u32): void;
export extern fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: i32, color: u32): void;
export extern fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: u32): void;
export extern fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: i32, color: u32): void;
export extern fn DrawEllipse(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: u32): void;
export extern fn DrawEllipseLines(centerX: i32, centerY: i32, radiusH: f32, radiusV: f32, color: u32): void;
export extern fn DrawRectangle(posX: i32, posY: i32, width: i32, height: i32, color: u32): void;
export extern fn DrawRectangleV(position: Vector2, size: Vector2, color: u32): void;
export extern fn DrawRectangleRec(rec: Rectangle, color: u32): void;
export extern fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: u32): void;
export extern fn DrawRectangleGradientV(posX: i32, posY: i32, width: i32, height: i32, color1: u32, color2: u32): void;
export extern fn DrawRectangleGradientH(posX: i32, posY: i32, width: i32, height: i32, color1: u32, color2: u32): void;
export extern fn DrawRectangleGradientEx(rec: Rectangle, col1: u32, col2: u32, col3: u32, col4: u32): void;
export extern fn DrawRectangleLines(posX: i32, posY: i32, width: i32, height: i32, color: u32): void;
export extern fn DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: u32): void;
export extern fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: i32, color: u32): void;
export extern fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: i32, color: u32): void;
export extern fn DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: i32, lineThick: f32, color: u32): void;
export extern fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: u32): void;
export extern fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: u32): void;
export extern fn DrawTriangleFan(points: ptr, pointCount: i32, color: u32): void;  // points: Vector2*
export extern fn DrawTriangleStrip(points: ptr, pointCount: i32, color: u32): void;  // points: Vector2*
export extern fn DrawPoly(center: Vector2, sides: i32, radius: f32, rotation: f32, color: u32): void;
export extern fn DrawPolyLines(center: Vector2, sides: i32, radius: f32, rotation: f32, color: u32): void;
export extern fn DrawPolyLinesEx(center: Vector2, sides: i32, radius: f32, rotation: f32, lineThick: f32, color: u32): void;

// ============================================================================
// Text - Drawing
// ============================================================================

export extern fn DrawText(text: string, posX: i32, posY: i32, fontSize: i32, color: u32): void;
export extern fn MeasureText(text: string, fontSize: i32): i32;

// ============================================================================
// Core - Timing
// ============================================================================

export extern fn WaitTime(seconds: f64): void;

// ============================================================================
// Core - Random
// ============================================================================

export extern fn GetRandomValue(min: i32, max: i32): i32;
export extern fn SetRandomSeed(seed: u32): void;

// ============================================================================
// Core - Misc
// ============================================================================

export extern fn TakeScreenshot(fileName: string): void;
export extern fn SetConfigFlags(flags: u32): void;
export extern fn OpenURL(url: string): void;

// ============================================================================
// Core - Clipboard
// ============================================================================

export extern fn SetClipboardText(text: string): void;
export extern fn GetClipboardText(): string;

// ============================================================================
// Shapes - Collision Detection
// ============================================================================

export extern fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle): i32;  // C: bool
export extern fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32): i32;  // C: bool
export extern fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle): i32;  // C: bool
export extern fn CheckCollisionPointRec(point: Vector2, rec: Rectangle): i32;  // C: bool
export extern fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32): i32;  // C: bool
export extern fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2): i32;  // C: bool
export extern fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: i32): i32;  // C: bool
export extern fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: ptr): i32;  // C: bool
export extern fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle): Rectangle;

// ============================================================================
// Text - Extended
// ============================================================================

export extern fn DrawFPS(posX: i32, posY: i32): void;

// ============================================================================
// Audio - Device Management
// ============================================================================

export extern fn InitAudioDevice(): void;
export extern fn CloseAudioDevice(): void;
export extern fn IsAudioDeviceReady(): i32;
export extern fn SetMasterVolume(volume: f32): void;
export extern fn GetMasterVolume(): f32;

// ============================================================================
// Textures - Loading and Drawing
// ============================================================================

export extern fn LoadTexture(fileName: string): Texture2D;
export extern fn LoadTextureFromImage(image: Image): Texture2D;
export extern fn UnloadTexture(texture: Texture2D): void;
export extern fn IsTextureValid(texture: Texture2D): i32;  // C: bool
export extern fn UpdateTexture(texture: Texture2D, pixels: ptr): void;
export extern fn DrawTexture(texture: Texture2D, posX: i32, posY: i32, tint: u32): void;
export extern fn DrawTextureV(texture: Texture2D, position: Vector2, tint: u32): void;
export extern fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: u32): void;
export extern fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: u32): void;
export extern fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: u32): void;

// Texture configuration
export extern fn SetTextureFilter(texture: Texture2D, filter: i32): void;
export extern fn SetTextureWrap(texture: Texture2D, wrap: i32): void;

// Render texture (for off-screen rendering)
export extern fn LoadRenderTexture(width: i32, height: i32): RenderTexture2D;
export extern fn UnloadRenderTexture(target: RenderTexture2D): void;
export extern fn IsRenderTextureValid(target: RenderTexture2D): i32;  // C: bool
export extern fn BeginTextureMode(target: RenderTexture2D): void;
export extern fn EndTextureMode(): void;

// ============================================================================
// Audio - Sound Loading and Playing
// ============================================================================

export extern fn LoadSound(fileName: string): Sound;
export extern fn UnloadSound(sound: Sound): void;
export extern fn IsSoundValid(sound: Sound): i32;  // C: bool
export extern fn PlaySound(sound: Sound): void;
export extern fn StopSound(sound: Sound): void;
export extern fn PauseSound(sound: Sound): void;
export extern fn ResumeSound(sound: Sound): void;
export extern fn IsSoundPlaying(sound: Sound): i32;  // C: bool
export extern fn SetSoundVolume(sound: Sound, volume: f32): void;
export extern fn SetSoundPitch(sound: Sound, pitch: f32): void;
export extern fn SetSoundPan(sound: Sound, pan: f32): void;

// ============================================================================
// Audio - Music Streaming
// ============================================================================

export extern fn LoadMusicStream(fileName: string): Music;
export extern fn UnloadMusicStream(music: Music): void;
export extern fn IsMusicValid(music: Music): i32;  // C: bool
export extern fn PlayMusicStream(music: Music): void;
export extern fn StopMusicStream(music: Music): void;
export extern fn PauseMusicStream(music: Music): void;
export extern fn ResumeMusicStream(music: Music): void;
export extern fn UpdateMusicStream(music: Music): void;
export extern fn IsMusicStreamPlaying(music: Music): i32;  // C: bool
export extern fn SetMusicVolume(music: Music, volume: f32): void;
export extern fn SetMusicPitch(music: Music, pitch: f32): void;
export extern fn SetMusicPan(music: Music, pan: f32): void;
export extern fn GetMusicTimeLength(music: Music): f32;
export extern fn GetMusicTimePlayed(music: Music): f32;
export extern fn SeekMusicStream(music: Music, position: f32): void;
export extern fn SetMusicLooping(music: Music, looping: i32): void;

// ============================================================================
// Text - Font Loading and Drawing
// ============================================================================

export extern fn LoadFont(fileName: string): Font;
export extern fn LoadFontEx(fileName: string, fontSize: i32, codepoints: ptr, codepointCount: i32): Font;
export extern fn UnloadFont(font: Font): void;
export extern fn IsFontValid(font: Font): i32;  // C: bool
export extern fn GetFontDefault(): Font;
export extern fn DrawTextEx(font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: u32): void;
export extern fn DrawTextPro(font: Font, text: string, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: u32): void;
export extern fn MeasureTextEx(font: Font, text: string, fontSize: f32, spacing: f32): Vector2;

// ============================================================================
// Images - Loading and Manipulation
// ============================================================================
// NOTE: Image manipulation functions take Image* (pointer) for in-place modification

export extern fn LoadImage(fileName: string): Image;
export extern fn LoadImageRaw(fileName: string, width: i32, height: i32, format: i32, headerSize: i32): Image;
export extern fn LoadImageFromMemory(fileType: string, fileData: ptr, dataSize: i32): Image;
export extern fn UnloadImage(image: Image): void;
export extern fn IsImageValid(image: Image): i32;  // C: bool
export extern fn ExportImage(image: Image, fileName: string): i32;  // C: bool

// Image generation
export extern fn GenImageColor(width: i32, height: i32, color: u32): Image;
export extern fn GenImageGradientLinear(width: i32, height: i32, direction: i32, start: u32, end: u32): Image;
export extern fn GenImageGradientRadial(width: i32, height: i32, density: f32, inner: u32, outer: u32): Image;
export extern fn GenImageChecked(width: i32, height: i32, checksX: i32, checksY: i32, col1: u32, col2: u32): Image;
export extern fn GenImageWhiteNoise(width: i32, height: i32, factor: f32): Image;
export extern fn GenImagePerlinNoise(width: i32, height: i32, offsetX: i32, offsetY: i32, scale: f32): Image;

// Image manipulation - pass pointer to image for in-place modification
export extern fn ImageCopy(image: Image): Image;
export extern fn ImageFromImage(image: Image, rec: Rectangle): Image;
export extern fn ImageResize(image: ptr, newWidth: i32, newHeight: i32): void;
export extern fn ImageResizeNN(image: ptr, newWidth: i32, newHeight: i32): void;
export extern fn ImageCrop(image: ptr, crop: Rectangle): void;
export extern fn ImageFlipVertical(image: ptr): void;
export extern fn ImageFlipHorizontal(image: ptr): void;
export extern fn ImageRotate(image: ptr, degrees: i32): void;
export extern fn ImageRotateCW(image: ptr): void;
export extern fn ImageRotateCCW(image: ptr): void;
export extern fn ImageColorTint(image: ptr, color: u32): void;
export extern fn ImageColorInvert(image: ptr): void;
export extern fn ImageColorGrayscale(image: ptr): void;
export extern fn ImageColorContrast(image: ptr, contrast: f32): void;
export extern fn ImageColorBrightness(image: ptr, brightness: i32): void;

// Image drawing
export extern fn ImageClearBackground(image: ptr, color: u32): void;
export extern fn ImageDrawPixel(image: ptr, posX: i32, posY: i32, color: u32): void;
export extern fn ImageDrawPixelV(image: ptr, position: Vector2, color: u32): void;
export extern fn ImageDrawLine(image: ptr, startX: i32, startY: i32, endX: i32, endY: i32, color: u32): void;
export extern fn ImageDrawLineV(image: ptr, start: Vector2, end: Vector2, color: u32): void;
export extern fn ImageDrawCircle(image: ptr, centerX: i32, centerY: i32, radius: i32, color: u32): void;
export extern fn ImageDrawCircleV(image: ptr, center: Vector2, radius: i32, color: u32): void;
export extern fn ImageDrawRectangle(image: ptr, posX: i32, posY: i32, width: i32, height: i32, color: u32): void;
export extern fn ImageDrawRectangleV(image: ptr, position: Vector2, size: Vector2, color: u32): void;
export extern fn ImageDrawRectangleRec(image: ptr, rec: Rectangle, color: u32): void;
export extern fn ImageDrawText(image: ptr, text: string, posX: i32, posY: i32, fontSize: i32, color: u32): void;
export extern fn ImageDrawTextEx(image: ptr, font: Font, text: string, position: Vector2, fontSize: f32, spacing: f32, tint: u32): void;

// ============================================================================
// File I/O Utilities
// ============================================================================
// C bool return types are mapped to i32 (0 = false, non-zero = true)

export extern fn FileExists(fileName: string): i32;           // C: bool
export extern fn DirectoryExists(dirPath: string): i32;       // C: bool
export extern fn IsFileExtension(fileName: string, ext: string): i32;  // C: bool
export extern fn GetFileExtension(fileName: string): string;  // C: const char*
export extern fn GetFileName(filePath: string): string;       // C: const char*
export extern fn GetFileNameWithoutExt(filePath: string): string;  // C: const char*
export extern fn GetDirectoryPath(filePath: string): string;  // C: const char*
export extern fn GetPrevDirectoryPath(dirPath: string): string;  // C: const char*
export extern fn GetWorkingDirectory(): string;               // C: const char*
export extern fn ChangeDirectory(dir: string): i32;           // C: bool
export extern fn GetFileLength(fileName: string): i32;
export extern fn GetFileModTime(fileName: string): i64;       // C: long
export extern fn IsPathFile(path: string): i32;               // C: bool
export extern fn GetApplicationDirectory(): string;           // C: const char*

// Text file I/O
export extern fn LoadFileText(fileName: string): string;      // C: char* (must be freed)
export extern fn UnloadFileText(text: string): void;
export extern fn SaveFileText(fileName: string, text: string): i32;  // C: bool

// ============================================================================
// Texture Filter/Wrap Constants
// ============================================================================

export let TEXTURE_FILTER_POINT: i32           = 0;
export let TEXTURE_FILTER_BILINEAR: i32        = 1;
export let TEXTURE_FILTER_TRILINEAR: i32       = 2;
export let TEXTURE_FILTER_ANISOTROPIC_4X: i32  = 3;
export let TEXTURE_FILTER_ANISOTROPIC_8X: i32  = 4;
export let TEXTURE_FILTER_ANISOTROPIC_16X: i32 = 5;

export let TEXTURE_WRAP_REPEAT: i32          = 0;
export let TEXTURE_WRAP_CLAMP: i32           = 1;
export let TEXTURE_WRAP_MIRROR_REPEAT: i32   = 2;
export let TEXTURE_WRAP_MIRROR_CLAMP: i32    = 3;

// ============================================================================
// Pixel Format Constants
// ============================================================================

export let PIXELFORMAT_UNCOMPRESSED_GRAYSCALE: i32    = 1;
export let PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA: i32   = 2;
export let PIXELFORMAT_UNCOMPRESSED_R5G6B5: i32       = 3;
export let PIXELFORMAT_UNCOMPRESSED_R8G8B8: i32       = 4;
export let PIXELFORMAT_UNCOMPRESSED_R5G5B5A1: i32     = 5;
export let PIXELFORMAT_UNCOMPRESSED_R4G4B4A4: i32     = 6;
export let PIXELFORMAT_UNCOMPRESSED_R8G8B8A8: i32     = 7;
export let PIXELFORMAT_UNCOMPRESSED_R32: i32          = 8;
export let PIXELFORMAT_UNCOMPRESSED_R32G32B32: i32    = 9;
export let PIXELFORMAT_UNCOMPRESSED_R32G32B32A32: i32 = 10;
export let PIXELFORMAT_UNCOMPRESSED_R16: i32          = 11;
export let PIXELFORMAT_UNCOMPRESSED_R16G16B16: i32    = 12;
export let PIXELFORMAT_UNCOMPRESSED_R16G16B16A16: i32 = 13;

// ============================================================================
// Color Constants (RGBA packed as u32 - little endian: ABGR in memory)
// ============================================================================

// On little-endian systems, Color struct {r,g,b,a} maps to memory as r,g,b,a
// When read as u32: a<<24 | b<<16 | g<<8 | r
export fn Color(r: u8, g: u8, b: u8, a: u8): u32 {
    let r32: u32 = r;
    let g32: u32 = g;
    let b32: u32 = b;
    let a32: u32 = a;
    return (a32 << 24) | (b32 << 16) | (g32 << 8) | r32;
}

// Color manipulation helpers
export fn ColorAlpha(color: u32, alpha: f32): u32 {
    let a: u32 = alpha * 255.0;
    if (a > 255) { a = 255; }
    return (color & 0x00FFFFFF) | (a << 24);
}

export fn ColorBrightness(color: u32, factor: f32): u32 {
    let r: u32 = color & 0xFF;
    let g: u32 = (color >> 8) & 0xFF;
    let b: u32 = (color >> 16) & 0xFF;
    let a: u32 = (color >> 24) & 0xFF;

    let nr: i32 = r * factor;
    let ng: i32 = g * factor;
    let nb: i32 = b * factor;

    if (nr > 255) { nr = 255; }
    if (ng > 255) { ng = 255; }
    if (nb > 255) { nb = 255; }
    if (nr < 0) { nr = 0; }
    if (ng < 0) { ng = 0; }
    if (nb < 0) { nb = 0; }

    return Color(nr, ng, nb, a);
}

// Extract color components
export fn ColorGetR(color: u32): u8 {
    return color & 0xFF;
}

export fn ColorGetG(color: u32): u8 {
    return (color >> 8) & 0xFF;
}

export fn ColorGetB(color: u32): u8 {
    return (color >> 16) & 0xFF;
}

export fn ColorGetA(color: u32): u8 {
    return (color >> 24) & 0xFF;
}

// ============================================================================
// Shape Drawing Helpers (using rlgl to avoid Vector2 struct issues)
// ============================================================================

// Draw a filled circle using pixels (workaround for ARM64 FFI float parameter bug)
// Note: DrawCircle doesn't work because Hemlock's FFI doesn't correctly pass floats on ARM64
export fn DrawCircleFill(centerX: i32, centerY: i32, radius: i32, color: u32) {
    let r2 = radius * radius;
    let y = -radius;
    while (y <= radius) {
        let x = -radius;
        while (x <= radius) {
            if (x * x + y * y <= r2) {
                DrawPixel(centerX + x, centerY + y, color);
            }
            x = x + 1;
        }
        y = y + 1;
    }
}

// Draw a circle outline using pixels (workaround for ARM64 FFI float parameter bug)
export fn DrawCircleOutline(centerX: i32, centerY: i32, radius: i32, color: u32) {
    // Midpoint circle algorithm
    let x = radius;
    let y = 0;
    let err = 0;

    while (x >= y) {
        DrawPixel(centerX + x, centerY + y, color);
        DrawPixel(centerX + y, centerY + x, color);
        DrawPixel(centerX - y, centerY + x, color);
        DrawPixel(centerX - x, centerY + y, color);
        DrawPixel(centerX - x, centerY - y, color);
        DrawPixel(centerX - y, centerY - x, color);
        DrawPixel(centerX + y, centerY - x, color);
        DrawPixel(centerX + x, centerY - y, color);

        y = y + 1;
        err = err + 1 + 2 * y;
        if (2 * (err - x) + 1 > 0) {
            x = x - 1;
            err = err + 1 - 2 * x;
        }
    }
}

// Draw a filled triangle using rlgl primitives
// This works around raylib's DrawTriangle which expects Vector2 structs
export fn DrawTriangleFill(v1x: f32, v1y: f32, v2x: f32, v2y: f32, v3x: f32, v3y: f32, color: u32) {
    let r = ColorGetR(color);
    let g = ColorGetG(color);
    let b = ColorGetB(color);
    let a = ColorGetA(color);

    rlBegin(RL_TRIANGLES);
    rlColor4ub(r, g, b, a);
    rlVertex2f(v1x, v1y);
    rlVertex2f(v2x, v2y);
    rlVertex2f(v3x, v3y);
    rlEnd();
}

// Draw a triangle outline using rlgl primitives
export fn DrawTriangleOutline(v1x: f32, v1y: f32, v2x: f32, v2y: f32, v3x: f32, v3y: f32, color: u32) {
    let r = ColorGetR(color);
    let g = ColorGetG(color);
    let b = ColorGetB(color);
    let a = ColorGetA(color);

    rlBegin(RL_LINES);
    rlColor4ub(r, g, b, a);
    // Line 1
    rlVertex2f(v1x, v1y);
    rlVertex2f(v2x, v2y);
    // Line 2
    rlVertex2f(v2x, v2y);
    rlVertex2f(v3x, v3y);
    // Line 3
    rlVertex2f(v3x, v3y);
    rlVertex2f(v1x, v1y);
    rlEnd();
}

// Standard colors
export let LIGHTGRAY: u32  = Color(200, 200, 200, 255);
export let GRAY: u32       = Color(130, 130, 130, 255);
export let DARKGRAY: u32   = Color(80, 80, 80, 255);
export let YELLOW: u32     = Color(253, 249, 0, 255);
export let GOLD: u32       = Color(255, 203, 0, 255);
export let ORANGE: u32     = Color(255, 161, 0, 255);
export let PINK: u32       = Color(255, 109, 194, 255);
export let RED: u32        = Color(230, 41, 55, 255);
export let MAROON: u32     = Color(190, 33, 55, 255);
export let GREEN: u32      = Color(0, 228, 48, 255);
export let LIME: u32       = Color(0, 158, 47, 255);
export let DARKGREEN: u32  = Color(0, 117, 44, 255);
export let SKYBLUE: u32    = Color(102, 191, 255, 255);
export let BLUE: u32       = Color(0, 121, 241, 255);
export let DARKBLUE: u32   = Color(0, 82, 172, 255);
export let PURPLE: u32     = Color(200, 122, 255, 255);
export let VIOLET: u32     = Color(135, 60, 190, 255);
export let DARKPURPLE: u32 = Color(112, 31, 126, 255);
export let BEIGE: u32      = Color(211, 176, 131, 255);
export let BROWN: u32      = Color(127, 106, 79, 255);
export let DARKBROWN: u32  = Color(76, 63, 47, 255);
export let WHITE: u32      = Color(255, 255, 255, 255);
export let BLACK: u32      = Color(0, 0, 0, 255);
export let BLANK: u32      = Color(0, 0, 0, 0);
export let MAGENTA: u32    = Color(255, 0, 255, 255);
export let RAYWHITE: u32   = Color(245, 245, 245, 255);

// ============================================================================
// Key Constants
// ============================================================================

export let KEY_NULL: i32        = 0;
export let KEY_APOSTROPHE: i32  = 39;
export let KEY_COMMA: i32       = 44;
export let KEY_MINUS: i32       = 45;
export let KEY_PERIOD: i32      = 46;
export let KEY_SLASH: i32       = 47;
export let KEY_ZERO: i32        = 48;
export let KEY_ONE: i32         = 49;
export let KEY_TWO: i32         = 50;
export let KEY_THREE: i32       = 51;
export let KEY_FOUR: i32        = 52;
export let KEY_FIVE: i32        = 53;
export let KEY_SIX: i32         = 54;
export let KEY_SEVEN: i32       = 55;
export let KEY_EIGHT: i32       = 56;
export let KEY_NINE: i32        = 57;
export let KEY_SEMICOLON: i32   = 59;
export let KEY_EQUAL: i32       = 61;
export let KEY_A: i32           = 65;
export let KEY_B: i32           = 66;
export let KEY_C: i32           = 67;
export let KEY_D: i32           = 68;
export let KEY_E: i32           = 69;
export let KEY_F: i32           = 70;
export let KEY_G: i32           = 71;
export let KEY_H: i32           = 72;
export let KEY_I: i32           = 73;
export let KEY_J: i32           = 74;
export let KEY_K: i32           = 75;
export let KEY_L: i32           = 76;
export let KEY_M: i32           = 77;
export let KEY_N: i32           = 78;
export let KEY_O: i32           = 79;
export let KEY_P: i32           = 80;
export let KEY_Q: i32           = 81;
export let KEY_R: i32           = 82;
export let KEY_S: i32           = 83;
export let KEY_T: i32           = 84;
export let KEY_U: i32           = 85;
export let KEY_V: i32           = 86;
export let KEY_W: i32           = 87;
export let KEY_X: i32           = 88;
export let KEY_Y: i32           = 89;
export let KEY_Z: i32           = 90;
export let KEY_LEFT_BRACKET: i32  = 91;
export let KEY_BACKSLASH: i32     = 92;
export let KEY_RIGHT_BRACKET: i32 = 93;
export let KEY_GRAVE: i32         = 96;
export let KEY_SPACE: i32       = 32;
export let KEY_ESCAPE: i32      = 256;
export let KEY_ENTER: i32       = 257;
export let KEY_TAB: i32         = 258;
export let KEY_BACKSPACE: i32   = 259;
export let KEY_INSERT: i32      = 260;
export let KEY_DELETE: i32      = 261;
export let KEY_RIGHT: i32       = 262;
export let KEY_LEFT: i32        = 263;
export let KEY_DOWN: i32        = 264;
export let KEY_UP: i32          = 265;
export let KEY_PAGE_UP: i32     = 266;
export let KEY_PAGE_DOWN: i32   = 267;
export let KEY_HOME: i32        = 268;
export let KEY_END: i32         = 269;
export let KEY_CAPS_LOCK: i32   = 280;
export let KEY_SCROLL_LOCK: i32 = 281;
export let KEY_NUM_LOCK: i32    = 282;
export let KEY_PRINT_SCREEN: i32 = 283;
export let KEY_PAUSE: i32       = 284;
export let KEY_F1: i32          = 290;
export let KEY_F2: i32          = 291;
export let KEY_F3: i32          = 292;
export let KEY_F4: i32          = 293;
export let KEY_F5: i32          = 294;
export let KEY_F6: i32          = 295;
export let KEY_F7: i32          = 296;
export let KEY_F8: i32          = 297;
export let KEY_F9: i32          = 298;
export let KEY_F10: i32         = 299;
export let KEY_F11: i32         = 300;
export let KEY_F12: i32         = 301;
export let KEY_LEFT_SHIFT: i32  = 340;
export let KEY_LEFT_CONTROL: i32 = 341;
export let KEY_LEFT_ALT: i32    = 342;
export let KEY_LEFT_SUPER: i32  = 343;
export let KEY_RIGHT_SHIFT: i32 = 344;
export let KEY_RIGHT_CONTROL: i32 = 345;
export let KEY_RIGHT_ALT: i32   = 346;
export let KEY_RIGHT_SUPER: i32 = 347;
export let KEY_KB_MENU: i32     = 348;

// Keypad keys
export let KEY_KP_0: i32        = 320;
export let KEY_KP_1: i32        = 321;
export let KEY_KP_2: i32        = 322;
export let KEY_KP_3: i32        = 323;
export let KEY_KP_4: i32        = 324;
export let KEY_KP_5: i32        = 325;
export let KEY_KP_6: i32        = 326;
export let KEY_KP_7: i32        = 327;
export let KEY_KP_8: i32        = 328;
export let KEY_KP_9: i32        = 329;
export let KEY_KP_DECIMAL: i32  = 330;
export let KEY_KP_DIVIDE: i32   = 331;
export let KEY_KP_MULTIPLY: i32 = 332;
export let KEY_KP_SUBTRACT: i32 = 333;
export let KEY_KP_ADD: i32      = 334;
export let KEY_KP_ENTER: i32    = 335;
export let KEY_KP_EQUAL: i32    = 336;

// ============================================================================
// Mouse Button Constants
// ============================================================================

export let MOUSE_BUTTON_LEFT: i32    = 0;
export let MOUSE_BUTTON_RIGHT: i32   = 1;
export let MOUSE_BUTTON_MIDDLE: i32  = 2;
export let MOUSE_BUTTON_SIDE: i32    = 3;
export let MOUSE_BUTTON_EXTRA: i32   = 4;
export let MOUSE_BUTTON_FORWARD: i32 = 5;
export let MOUSE_BUTTON_BACK: i32    = 6;

// ============================================================================
// Mouse Cursor Constants
// ============================================================================

export let MOUSE_CURSOR_DEFAULT: i32       = 0;
export let MOUSE_CURSOR_ARROW: i32         = 1;
export let MOUSE_CURSOR_IBEAM: i32         = 2;
export let MOUSE_CURSOR_CROSSHAIR: i32     = 3;
export let MOUSE_CURSOR_POINTING_HAND: i32 = 4;
export let MOUSE_CURSOR_RESIZE_EW: i32     = 5;
export let MOUSE_CURSOR_RESIZE_NS: i32     = 6;
export let MOUSE_CURSOR_RESIZE_NWSE: i32   = 7;
export let MOUSE_CURSOR_RESIZE_NESW: i32   = 8;
export let MOUSE_CURSOR_RESIZE_ALL: i32    = 9;
export let MOUSE_CURSOR_NOT_ALLOWED: i32   = 10;

// ============================================================================
// Gamepad Constants
// ============================================================================

export let GAMEPAD_BUTTON_UNKNOWN: i32          = 0;
export let GAMEPAD_BUTTON_LEFT_FACE_UP: i32     = 1;
export let GAMEPAD_BUTTON_LEFT_FACE_RIGHT: i32  = 2;
export let GAMEPAD_BUTTON_LEFT_FACE_DOWN: i32   = 3;
export let GAMEPAD_BUTTON_LEFT_FACE_LEFT: i32   = 4;
export let GAMEPAD_BUTTON_RIGHT_FACE_UP: i32    = 5;
export let GAMEPAD_BUTTON_RIGHT_FACE_RIGHT: i32 = 6;
export let GAMEPAD_BUTTON_RIGHT_FACE_DOWN: i32  = 7;
export let GAMEPAD_BUTTON_RIGHT_FACE_LEFT: i32  = 8;
export let GAMEPAD_BUTTON_LEFT_TRIGGER_1: i32   = 9;
export let GAMEPAD_BUTTON_LEFT_TRIGGER_2: i32   = 10;
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_1: i32  = 11;
export let GAMEPAD_BUTTON_RIGHT_TRIGGER_2: i32  = 12;
export let GAMEPAD_BUTTON_MIDDLE_LEFT: i32      = 13;
export let GAMEPAD_BUTTON_MIDDLE: i32           = 14;
export let GAMEPAD_BUTTON_MIDDLE_RIGHT: i32     = 15;
export let GAMEPAD_BUTTON_LEFT_THUMB: i32       = 16;
export let GAMEPAD_BUTTON_RIGHT_THUMB: i32      = 17;

export let GAMEPAD_AXIS_LEFT_X: i32        = 0;
export let GAMEPAD_AXIS_LEFT_Y: i32        = 1;
export let GAMEPAD_AXIS_RIGHT_X: i32       = 2;
export let GAMEPAD_AXIS_RIGHT_Y: i32       = 3;
export let GAMEPAD_AXIS_LEFT_TRIGGER: i32  = 4;
export let GAMEPAD_AXIS_RIGHT_TRIGGER: i32 = 5;

// ============================================================================
// Gesture Constants
// ============================================================================

export let GESTURE_NONE: u32        = 0;
export let GESTURE_TAP: u32         = 1;
export let GESTURE_DOUBLETAP: u32   = 2;
export let GESTURE_HOLD: u32        = 4;
export let GESTURE_DRAG: u32        = 8;
export let GESTURE_SWIPE_RIGHT: u32 = 16;
export let GESTURE_SWIPE_LEFT: u32  = 32;
export let GESTURE_SWIPE_UP: u32    = 64;
export let GESTURE_SWIPE_DOWN: u32  = 128;
export let GESTURE_PINCH_IN: u32    = 256;
export let GESTURE_PINCH_OUT: u32   = 512;

// ============================================================================
// Blend Mode Constants
// ============================================================================

export let BLEND_ALPHA: i32             = 0;
export let BLEND_ADDITIVE: i32          = 1;
export let BLEND_MULTIPLIED: i32        = 2;
export let BLEND_ADD_COLORS: i32        = 3;
export let BLEND_SUBTRACT_COLORS: i32   = 4;
export let BLEND_ALPHA_PREMULTIPLY: i32 = 5;
export let BLEND_CUSTOM: i32            = 6;
export let BLEND_CUSTOM_SEPARATE: i32   = 7;

// ============================================================================
// Config Flags (for SetConfigFlags before InitWindow)
// ============================================================================

export let FLAG_VSYNC_HINT: u32               = 0x00000040;
export let FLAG_FULLSCREEN_MODE: u32          = 0x00000002;
export let FLAG_WINDOW_RESIZABLE: u32         = 0x00000004;
export let FLAG_WINDOW_UNDECORATED: u32       = 0x00000008;
export let FLAG_WINDOW_HIDDEN: u32            = 0x00000080;
export let FLAG_WINDOW_MINIMIZED: u32         = 0x00000200;
export let FLAG_WINDOW_MAXIMIZED: u32         = 0x00000400;
export let FLAG_WINDOW_UNFOCUSED: u32         = 0x00000800;
export let FLAG_WINDOW_TOPMOST: u32           = 0x00001000;
export let FLAG_WINDOW_ALWAYS_RUN: u32        = 0x00000100;
export let FLAG_WINDOW_TRANSPARENT: u32       = 0x00000010;
export let FLAG_WINDOW_HIGHDPI: u32           = 0x00002000;
export let FLAG_WINDOW_MOUSE_PASSTHROUGH: u32 = 0x00004000;
export let FLAG_BORDERLESS_WINDOWED_MODE: u32 = 0x00008000;
export let FLAG_MSAA_4X_HINT: u32             = 0x00000020;
export let FLAG_INTERLACED_HINT: u32          = 0x00010000;

// ============================================================================
// Log Level Constants
// ============================================================================

export let LOG_ALL: i32     = 0;
export let LOG_TRACE: i32   = 1;
export let LOG_DEBUG: i32   = 2;
export let LOG_INFO: i32    = 3;
export let LOG_WARNING: i32 = 4;
export let LOG_ERROR: i32   = 5;
export let LOG_FATAL: i32   = 6;
export let LOG_NONE: i32    = 7;

// ============================================================================
// Collision Detection Helpers
// ============================================================================

// Check collision between two circles (coordinate-based)
export fn CheckCollisionCirclesXY(c1x: f32, c1y: f32, r1: f32, c2x: f32, c2y: f32, r2: f32): i32 {
    let dx = c2x - c1x;
    let dy = c2y - c1y;
    let distSq = dx * dx + dy * dy;
    let radiusSum = r1 + r2;
    if (distSq <= radiusSum * radiusSum) {
        return 1;
    }
    return 0;
}

// Check collision between two rectangles (coordinate-based)
export fn CheckCollisionRectsXY(x1: f32, y1: f32, w1: f32, h1: f32, x2: f32, y2: f32, w2: f32, h2: f32): i32 {
    if (x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2) {
        return 1;
    }
    return 0;
}

// Check collision between point and rectangle
export fn CheckCollisionPointRectXY(px: f32, py: f32, rx: f32, ry: f32, rw: f32, rh: f32): i32 {
    if (px >= rx && px <= rx + rw && py >= ry && py <= ry + rh) {
        return 1;
    }
    return 0;
}

// Check collision between point and circle
export fn CheckCollisionPointCircleXY(px: f32, py: f32, cx: f32, cy: f32, r: f32): i32 {
    let dx = px - cx;
    let dy = py - cy;
    let distSq = dx * dx + dy * dy;
    if (distSq <= r * r) {
        return 1;
    }
    return 0;
}

// Check collision between circle and rectangle
export fn CheckCollisionCircleRecXY(cx: f32, cy: f32, r: f32, rx: f32, ry: f32, rw: f32, rh: f32): i32 {
    // Find closest point on rectangle to circle center
    let closestX = cx;
    let closestY = cy;

    if (cx < rx) { closestX = rx; }
    else if (cx > rx + rw) { closestX = rx + rw; }

    if (cy < ry) { closestY = ry; }
    else if (cy > ry + rh) { closestY = ry + rh; }

    let dx = cx - closestX;
    let dy = cy - closestY;
    let distSq = dx * dx + dy * dy;

    if (distSq <= r * r) {
        return 1;
    }
    return 0;
}

// ============================================================================
// Utility Functions
// ============================================================================

// Vector2 distance
export fn Vector2Distance(x1: f32, y1: f32, x2: f32, y2: f32): f32 {
    let dx = x2 - x1;
    let dy = y2 - y1;
    return sqrt(dx * dx + dy * dy);
}

// Vector2 length
export fn Vector2Length(x: f32, y: f32): f32 {
    return sqrt(x * x + y * y);
}

// Vector2 dot product
export fn Vector2Dot(x1: f32, y1: f32, x2: f32, y2: f32): f32 {
    return x1 * x2 + y1 * y2;
}

// Lerp helper
export fn Lerp(start: f32, end: f32, amount: f32): f32 {
    return start + amount * (end - start);
}

// Clamp helper
export fn Clamp(value: f32, min: f32, max: f32): f32 {
    if (value < min) { return min; }
    if (value > max) { return max; }
    return value;
}

// Clamp integer helper
export fn ClampInt(value: i32, min: i32, max: i32): i32 {
    if (value < min) { return min; }
    if (value > max) { return max; }
    return value;
}

// Remap value from one range to another
export fn Remap(value: f32, inputStart: f32, inputEnd: f32, outputStart: f32, outputEnd: f32): f32 {
    return outputStart + (value - inputStart) / (inputEnd - inputStart) * (outputEnd - outputStart);
}

// Wrap value within range [min, max)
export fn Wrap(value: f32, min: f32, max: f32): f32 {
    let range = max - min;
    let result = value - min;
    while (result < 0.0) { result = result + range; }
    while (result >= range) { result = result - range; }
    return result + min;
}

// Normalize angle to [0, 360)
export fn NormalizeAngle(angle: f32): f32 {
    let result = angle;
    while (result < 0.0) { result = result + 360.0; }
    while (result >= 360.0) { result = result - 360.0; }
    return result;
}

// Degrees to radians
export fn Deg2Rad(degrees: f32): f32 {
    return degrees * 0.01745329251994329577;
}

// Radians to degrees
export fn Rad2Deg(radians: f32): f32 {
    return radians * 57.29577951308232087680;
}

// ============================================================================
// Extended Math Utility Functions
// ============================================================================

// Sign of a float (-1, 0, or 1)
export fn Sign(value: f32): f32 {
    if (value > 0.0) { return 1.0; }
    if (value < 0.0) { return -1.0; }
    return 0.0;
}

// Sign of an integer (-1, 0, or 1)
export fn SignInt(value: i32): i32 {
    if (value > 0) { return 1; }
    if (value < 0) { return -1; }
    return 0;
}

// Absolute value of float
export fn Abs(value: f32): f32 {
    if (value < 0.0) { return -value; }
    return value;
}

// Absolute value of integer
export fn AbsInt(value: i32): i32 {
    if (value < 0) { return -value; }
    return value;
}

// Minimum of two floats
export fn Min(a: f32, b: f32): f32 {
    if (a < b) { return a; }
    return b;
}

// Maximum of two floats
export fn Max(a: f32, b: f32): f32 {
    if (a > b) { return a; }
    return b;
}

// Minimum of two integers
export fn MinInt(a: i32, b: i32): i32 {
    if (a < b) { return a; }
    return b;
}

// Maximum of two integers
export fn MaxInt(a: i32, b: i32): i32 {
    if (a > b) { return a; }
    return b;
}

// Floor of a float (returns integer)
export fn FloorInt(value: f32): i32 {
    let i: i32 = value;
    if (value < 0.0 && value != i) { return i - 1; }
    return i;
}

// Ceiling of a float (returns integer)
export fn CeilInt(value: f32): i32 {
    let i: i32 = value;
    if (value > 0.0 && value != i) { return i + 1; }
    return i;
}

// Round to nearest integer
export fn RoundInt(value: f32): i32 {
    if (value >= 0.0) { return FloorInt(value + 0.5); }
    return CeilInt(value - 0.5);
}

// Smooth step interpolation (Hermite)
export fn SmoothStep(edge0: f32, edge1: f32, x: f32): f32 {
    let t = Clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

// Inverse lerp - find t given start, end, and value
export fn InverseLerp(start: f32, end: f32, value: f32): f32 {
    if (start == end) { return 0.0; }
    return (value - start) / (end - start);
}

// Move towards target value by a maximum delta
export fn MoveTowards(current: f32, target: f32, maxDelta: f32): f32 {
    let diff = target - current;
    if (Abs(diff) <= maxDelta) { return target; }
    return current + Sign(diff) * maxDelta;
}

// Move towards target integer by a maximum delta
export fn MoveTowardsInt(current: i32, target: i32, maxDelta: i32): i32 {
    let diff = target - current;
    if (AbsInt(diff) <= maxDelta) { return target; }
    return current + SignInt(diff) * maxDelta;
}

// Check if value is approximately equal (within epsilon)
export fn Approximately(a: f32, b: f32, epsilon: f32): i32 {
    let diff = a - b;
    if (diff < 0.0) { diff = -diff; }
    if (diff <= epsilon) { return 1; }
    return 0;
}

// Check if value is within range [min, max]
export fn InRange(value: f32, min: f32, max: f32): i32 {
    if (value >= min && value <= max) { return 1; }
    return 0;
}

// Check if integer is within range [min, max]
export fn InRangeInt(value: i32, min: i32, max: i32): i32 {
    if (value >= min && value <= max) { return 1; }
    return 0;
}

// Wrap integer within range [min, max)
export fn WrapInt(value: i32, min: i32, max: i32): i32 {
    let range = max - min;
    let result = value - min;
    while (result < 0) { result = result + range; }
    while (result >= range) { result = result - range; }
    return result + min;
}

// ============================================================================
// Extended Vector2 Utility Functions
// ============================================================================

// Vector2 normalize (returns components via out parameters pattern - using tuple simulation)
// Since Hemlock doesn't have multiple return values, we return length and caller can divide
export fn Vector2LengthSq(x: f32, y: f32): f32 {
    return x * x + y * y;
}

// Normalize vector and return new length (x and y should be divided by length externally)
export fn Vector2NormalizeGetLength(x: f32, y: f32): f32 {
    let length = Vector2Length(x, y);
    if (length == 0.0) { return 0.0; }
    return length;
}

// Scale vector components
export fn Vector2ScaleX(x: f32, scale: f32): f32 {
    return x * scale;
}

export fn Vector2ScaleY(y: f32, scale: f32): f32 {
    return y * scale;
}

// Add two vectors (return X component)
export fn Vector2AddX(x1: f32, x2: f32): f32 {
    return x1 + x2;
}

// Add two vectors (return Y component)
export fn Vector2AddY(y1: f32, y2: f32): f32 {
    return y1 + y2;
}

// Subtract vectors (return X component)
export fn Vector2SubtractX(x1: f32, x2: f32): f32 {
    return x1 - x2;
}

// Subtract vectors (return Y component)
export fn Vector2SubtractY(y1: f32, y2: f32): f32 {
    return y1 - y2;
}

// Negate vector (return X component)
export fn Vector2NegateX(x: f32): f32 {
    return -x;
}

// Negate vector (return Y component)
export fn Vector2NegateY(y: f32): f32 {
    return -y;
}

// Rotate vector (return X component)
export fn Vector2RotateX(x: f32, y: f32, angle: f32): f32 {
    let rad = Deg2Rad(angle);
    let cosA = cos(rad);
    let sinA = sin(rad);
    return x * cosA - y * sinA;
}

// Rotate vector (return Y component)
export fn Vector2RotateY(x: f32, y: f32, angle: f32): f32 {
    let rad = Deg2Rad(angle);
    let cosA = cos(rad);
    let sinA = sin(rad);
    return x * sinA + y * cosA;
}

// Lerp between two points (return X component)
export fn Vector2LerpX(x1: f32, x2: f32, amount: f32): f32 {
    return Lerp(x1, x2, amount);
}

// Lerp between two points (return Y component)
export fn Vector2LerpY(y1: f32, y2: f32, amount: f32): f32 {
    return Lerp(y1, y2, amount);
}

// Reflect vector off a normal (return X component)
export fn Vector2ReflectX(vx: f32, vy: f32, nx: f32, ny: f32): f32 {
    let dot = Vector2Dot(vx, vy, nx, ny);
    return vx - 2.0 * dot * nx;
}

// Reflect vector off a normal (return Y component)
export fn Vector2ReflectY(vx: f32, vy: f32, nx: f32, ny: f32): f32 {
    let dot = Vector2Dot(vx, vy, nx, ny);
    return vy - 2.0 * dot * ny;
}

// Get angle between two vectors in degrees
export fn Vector2Angle(x1: f32, y1: f32, x2: f32, y2: f32): f32 {
    let dot = Vector2Dot(x1, y1, x2, y2);
    let len1 = Vector2Length(x1, y1);
    let len2 = Vector2Length(x2, y2);
    if (len1 == 0.0 || len2 == 0.0) { return 0.0; }
    let cosAngle = dot / (len1 * len2);
    // Clamp to avoid acos domain errors
    if (cosAngle > 1.0) { cosAngle = 1.0; }
    if (cosAngle < -1.0) { cosAngle = -1.0; }
    return Rad2Deg(acos(cosAngle));
}

// Get angle of vector from positive X axis in degrees
export fn Vector2AngleFromX(x: f32, y: f32): f32 {
    return Rad2Deg(atan2(y, x));
}

// Move point towards target by max distance (return X component)
export fn Vector2MoveTowardsX(currentX: f32, currentY: f32, targetX: f32, targetY: f32, maxDistance: f32): f32 {
    let dx = targetX - currentX;
    let dy = targetY - currentY;
    let dist = Vector2Length(dx, dy);
    if (dist <= maxDistance || dist == 0.0) { return targetX; }
    return currentX + dx / dist * maxDistance;
}

// Move point towards target by max distance (return Y component)
export fn Vector2MoveTowardsY(currentX: f32, currentY: f32, targetX: f32, targetY: f32, maxDistance: f32): f32 {
    let dx = targetX - currentX;
    let dy = targetY - currentY;
    let dist = Vector2Length(dx, dy);
    if (dist <= maxDistance || dist == 0.0) { return targetY; }
    return currentY + dy / dist * maxDistance;
}

// ============================================================================
// Extended Collision Detection
// ============================================================================

// Check if two line segments intersect
export fn CheckCollisionLinesXY(p1x: f32, p1y: f32, p2x: f32, p2y: f32, p3x: f32, p3y: f32, p4x: f32, p4y: f32): i32 {
    let d1x = p2x - p1x;
    let d1y = p2y - p1y;
    let d2x = p4x - p3x;
    let d2y = p4y - p3y;

    // Handle degenerate zero-length lines (points)
    if (d1x == 0.0 && d1y == 0.0) { return 0; }
    if (d2x == 0.0 && d2y == 0.0) { return 0; }

    let cross = d1x * d2y - d1y * d2x;

    // Variables for collinear case (declared at function scope for Hemlock compatibility)
    let crossP3: f32 = 0.0;
    let min1: f32 = 0.0;
    let max1: f32 = 0.0;
    let min2: f32 = 0.0;
    let max2: f32 = 0.0;

    // Handle collinear/parallel case
    if (cross == 0.0) {
        // Check if lines are collinear by testing if p3 lies on line through p1-p2
        crossP3 = (p3x - p1x) * d1y - (p3y - p1y) * d1x;
        if (crossP3 != 0.0) { return 0; } // Parallel but not collinear

        // Collinear - check if segments overlap
        // Project onto the axis with larger extent
        if (Abs(d1x) >= Abs(d1y)) {
            // Use X axis
            min1 = Min(p1x, p2x);
            max1 = Max(p1x, p2x);
            min2 = Min(p3x, p4x);
            max2 = Max(p3x, p4x);
        } else {
            // Use Y axis
            min1 = Min(p1y, p2y);
            max1 = Max(p1y, p2y);
            min2 = Min(p3y, p4y);
            max2 = Max(p3y, p4y);
        }
        if (max1 >= min2 && max2 >= min1) { return 1; }
        return 0;
    }

    let dx = p3x - p1x;
    let dy = p3y - p1y;

    let t = (dx * d2y - dy * d2x) / cross;
    let u = (dx * d1y - dy * d1x) / cross;

    if (t >= 0.0 && t <= 1.0 && u >= 0.0 && u <= 1.0) {
        return 1;
    }
    return 0;
}

// Check if point is inside triangle (using barycentric coordinates)
export fn CheckCollisionPointTriangleXY(px: f32, py: f32, ax: f32, ay: f32, bx: f32, by: f32, cx: f32, cy: f32): i32 {
    let v0x = cx - ax;
    let v0y = cy - ay;
    let v1x = bx - ax;
    let v1y = by - ay;
    let v2x = px - ax;
    let v2y = py - ay;

    let dot00 = v0x * v0x + v0y * v0y;
    let dot01 = v0x * v1x + v0y * v1y;
    let dot02 = v0x * v2x + v0y * v2y;
    let dot11 = v1x * v1x + v1y * v1y;
    let dot12 = v1x * v2x + v1y * v2y;

    let denom = dot00 * dot11 - dot01 * dot01;

    // Handle degenerate triangle (all vertices at same point)
    if (denom == 0.0) {
        // Check if point is at the same location as the degenerate triangle
        if (px == ax && py == ay) { return 1; }
        return 0;
    }

    let invDenom = 1.0 / denom;
    let u = (dot11 * dot02 - dot01 * dot12) * invDenom;
    let v = (dot00 * dot12 - dot01 * dot02) * invDenom;

    if (u >= 0.0 && v >= 0.0 && u + v <= 1.0) {
        return 1;
    }
    return 0;
}

// Check if point is on line segment (within tolerance)
export fn CheckCollisionPointLineXY(px: f32, py: f32, p1x: f32, p1y: f32, p2x: f32, p2y: f32, threshold: f32): i32 {
    let d1 = Vector2Distance(px, py, p1x, p1y);
    let d2 = Vector2Distance(px, py, p2x, p2y);
    let lineLen = Vector2Distance(p1x, p1y, p2x, p2y);

    if (d1 + d2 >= lineLen - threshold && d1 + d2 <= lineLen + threshold) {
        return 1;
    }
    return 0;
}

// ============================================================================
// Easing Functions
// ============================================================================

// Linear (no easing)
export fn EaseLinear(t: f32): f32 {
    return t;
}

// Quadratic easing
export fn EaseInQuad(t: f32): f32 {
    return t * t;
}

export fn EaseOutQuad(t: f32): f32 {
    return t * (2.0 - t);
}

export fn EaseInOutQuad(t: f32): f32 {
    if (t < 0.5) {
        return 2.0 * t * t;
    }
    return -1.0 + (4.0 - 2.0 * t) * t;
}

// Cubic easing
export fn EaseInCubic(t: f32): f32 {
    return t * t * t;
}

export fn EaseOutCubic(t: f32): f32 {
    let t1 = t - 1.0;
    return t1 * t1 * t1 + 1.0;
}

export fn EaseInOutCubic(t: f32): f32 {
    if (t < 0.5) {
        return 4.0 * t * t * t;
    }
    let t1 = 2.0 * t - 2.0;
    return 0.5 * t1 * t1 * t1 + 1.0;
}

// Quartic easing
export fn EaseInQuart(t: f32): f32 {
    return t * t * t * t;
}

export fn EaseOutQuart(t: f32): f32 {
    let t1 = t - 1.0;
    return 1.0 - t1 * t1 * t1 * t1;
}

export fn EaseInOutQuart(t: f32): f32 {
    if (t < 0.5) {
        return 8.0 * t * t * t * t;
    }
    let t1 = t - 1.0;
    return 1.0 - 8.0 * t1 * t1 * t1 * t1;
}

// Quintic easing
export fn EaseInQuint(t: f32): f32 {
    return t * t * t * t * t;
}

export fn EaseOutQuint(t: f32): f32 {
    let t1 = t - 1.0;
    return 1.0 + t1 * t1 * t1 * t1 * t1;
}

export fn EaseInOutQuint(t: f32): f32 {
    if (t < 0.5) {
        return 16.0 * t * t * t * t * t;
    }
    let t1 = 2.0 * t - 2.0;
    return 0.5 * t1 * t1 * t1 * t1 * t1 + 1.0;
}

// Sine easing
export fn EaseInSine(t: f32): f32 {
    return 1.0 - cos(t * 1.5707963267948966);
}

export fn EaseOutSine(t: f32): f32 {
    return sin(t * 1.5707963267948966);
}

export fn EaseInOutSine(t: f32): f32 {
    return 0.5 * (1.0 - cos(3.141592653589793 * t));
}

// Exponential easing
export fn EaseInExpo(t: f32): f32 {
    if (t == 0.0) { return 0.0; }
    return pow(2.0, 10.0 * (t - 1.0));
}

export fn EaseOutExpo(t: f32): f32 {
    if (t == 1.0) { return 1.0; }
    return 1.0 - pow(2.0, -10.0 * t);
}

export fn EaseInOutExpo(t: f32): f32 {
    if (t == 0.0) { return 0.0; }
    if (t == 1.0) { return 1.0; }
    if (t < 0.5) {
        return 0.5 * pow(2.0, 20.0 * t - 10.0);
    }
    return 1.0 - 0.5 * pow(2.0, -20.0 * t + 10.0);
}

// Circular easing
export fn EaseInCirc(t: f32): f32 {
    return 1.0 - sqrt(1.0 - t * t);
}

export fn EaseOutCirc(t: f32): f32 {
    let t1 = t - 1.0;
    return sqrt(1.0 - t1 * t1);
}

export fn EaseInOutCirc(t: f32): f32 {
    if (t < 0.5) {
        return 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t));
    }
    let t1 = 2.0 * t - 2.0;
    return 0.5 * (sqrt(1.0 - t1 * t1) + 1.0);
}

// Back easing (overshoots)
export fn EaseInBack(t: f32): f32 {
    let c1 = 1.70158;
    let c3 = c1 + 1.0;
    return c3 * t * t * t - c1 * t * t;
}

export fn EaseOutBack(t: f32): f32 {
    let c1 = 1.70158;
    let c3 = c1 + 1.0;
    let t1 = t - 1.0;
    return 1.0 + c3 * t1 * t1 * t1 + c1 * t1 * t1;
}

export fn EaseInOutBack(t: f32): f32 {
    let c1 = 1.70158;
    let c2 = c1 * 1.525;
    if (t < 0.5) {
        return 0.5 * (4.0 * t * t * ((c2 + 1.0) * 2.0 * t - c2));
    }
    let t1 = 2.0 * t - 2.0;
    return 0.5 * (t1 * t1 * ((c2 + 1.0) * t1 + c2) + 2.0);
}

// Bounce easing
export fn EaseOutBounce(t: f32): f32 {
    let n1 = 7.5625;
    let d1 = 2.75;

    if (t < 1.0 / d1) {
        return n1 * t * t;
    } else if (t < 2.0 / d1) {
        let t1 = t - 1.5 / d1;
        return n1 * t1 * t1 + 0.75;
    } else if (t < 2.5 / d1) {
        let t1 = t - 2.25 / d1;
        return n1 * t1 * t1 + 0.9375;
    } else {
        let t1 = t - 2.625 / d1;
        return n1 * t1 * t1 + 0.984375;
    }
}

export fn EaseInBounce(t: f32): f32 {
    return 1.0 - EaseOutBounce(1.0 - t);
}

export fn EaseInOutBounce(t: f32): f32 {
    if (t < 0.5) {
        return 0.5 * (1.0 - EaseOutBounce(1.0 - 2.0 * t));
    }
    return 0.5 * (1.0 + EaseOutBounce(2.0 * t - 1.0));
}

// Elastic easing
export fn EaseInElastic(t: f32): f32 {
    if (t == 0.0) { return 0.0; }
    if (t == 1.0) { return 1.0; }
    let c4 = 6.283185307179586 / 3.0;
    return -pow(2.0, 10.0 * t - 10.0) * sin((t * 10.0 - 10.75) * c4);
}

export fn EaseOutElastic(t: f32): f32 {
    if (t == 0.0) { return 0.0; }
    if (t == 1.0) { return 1.0; }
    let c4 = 6.283185307179586 / 3.0;
    return pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * c4) + 1.0;
}

export fn EaseInOutElastic(t: f32): f32 {
    if (t == 0.0) { return 0.0; }
    if (t == 1.0) { return 1.0; }
    let c5 = 6.283185307179586 / 4.5;
    if (t < 0.5) {
        return -0.5 * pow(2.0, 20.0 * t - 10.0) * sin((20.0 * t - 11.125) * c5);
    }
    return 0.5 * pow(2.0, -20.0 * t + 10.0) * sin((20.0 * t - 11.125) * c5) + 1.0;
}

// ============================================================================
// Color Utility Functions (Extended)
// ============================================================================

// Blend two colors (alpha blend)
export fn ColorBlend(color1: u32, color2: u32, factor: f32): u32 {
    let r1: i32 = color1 & 0xFF;
    let g1: i32 = (color1 >> 8) & 0xFF;
    let b1: i32 = (color1 >> 16) & 0xFF;
    let a1: i32 = (color1 >> 24) & 0xFF;

    let r2: i32 = color2 & 0xFF;
    let g2: i32 = (color2 >> 8) & 0xFF;
    let b2: i32 = (color2 >> 16) & 0xFF;
    let a2: i32 = (color2 >> 24) & 0xFF;

    let r: i32 = Lerp(r1, r2, factor);
    let g: i32 = Lerp(g1, g2, factor);
    let b: i32 = Lerp(b1, b2, factor);
    let a: i32 = Lerp(a1, a2, factor);

    return Color(r, g, b, a);
}

// Invert a color (keep alpha)
export fn ColorInvert(color: u32): u32 {
    let r: u8 = 255 - ColorGetR(color);
    let g: u8 = 255 - ColorGetG(color);
    let b: u8 = 255 - ColorGetB(color);
    let a: u8 = ColorGetA(color);
    return Color(r, g, b, a);
}

// Convert color to grayscale
export fn ColorToGrayscale(color: u32): u32 {
    let r: i32 = ColorGetR(color);
    let g: i32 = ColorGetG(color);
    let b: i32 = ColorGetB(color);
    let a: u8 = ColorGetA(color);
    // Standard luminance formula
    let gray: i32 = divi(r * 299 + g * 587 + b * 114, 1000);
    return Color(gray, gray, gray, a);
}

// Tint a color (multiply RGB by another color)
export fn ColorTint(color: u32, tint: u32): u32 {
    let r1: i32 = ColorGetR(color);
    let g1: i32 = ColorGetG(color);
    let b1: i32 = ColorGetB(color);
    let a1: u8 = ColorGetA(color);

    let r2: i32 = ColorGetR(tint);
    let g2: i32 = ColorGetG(tint);
    let b2: i32 = ColorGetB(tint);

    let r: i32 = divi(r1 * r2, 255);
    let g: i32 = divi(g1 * g2, 255);
    let b: i32 = divi(b1 * b2, 255);

    return Color(r, g, b, a1);
}

// Contrast adjustment (-1.0 to 1.0)
export fn ColorContrast(color: u32, contrast: f32): u32 {
    let r: f32 = ColorGetR(color);
    let g: f32 = ColorGetG(color);
    let b: f32 = ColorGetB(color);
    let a: u8 = ColorGetA(color);

    let factor = (1.0 + contrast) / (1.0 - contrast);

    r = (r / 255.0 - 0.5) * factor + 0.5;
    g = (g / 255.0 - 0.5) * factor + 0.5;
    b = (b / 255.0 - 0.5) * factor + 0.5;

    let ri: i32 = Clamp(r * 255.0, 0.0, 255.0);
    let gi: i32 = Clamp(g * 255.0, 0.0, 255.0);
    let bi: i32 = Clamp(b * 255.0, 0.0, 255.0);

    return Color(ri, gi, bi, a);
}
